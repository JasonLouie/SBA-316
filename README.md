# SBA-316
For this SBA, a clone of the popular game wordle was created. The UI mostly resembles the original WORDLE game, but there are a few differences. The web keyboard is more responsive (hovering over each key darkens the key), different login/signup overlay, results overlay displaying a gif, and time elapsed.

## Game Constraints
This implementation of wordle is almost "perfect" in the sense that it functions almost as expected. The game properly updates colors on the keyboard and guesses based on whether the letter exists, doesn't exist, or is in the correct position. The main flaw is a word list with a small subset of words and the lack of word validation (no logic implemented to validate that a word exists in the English dictionary). The game handles repeated guesses and guesses that are too short with a custom made alert that disappears after 2 seconds with `setTimeOut`. This alert also isn't implemented in the best way since spamming errors will lead to unexpected behavior (the alert randomly disappearing and appearing because the same error is being displayed over and over because textContent of the element child is modified). The web keyboard exists for mobile users and/or desktop users that prefer using these keys to type.

## Game Logic
This implementation is carried by two event listeners, `handleWebKeyboard(e)` and `handleUserKeyboard(e)`, that handle user input. The first event listener is used to gather user input from the web keyboard, while the latter is used to gather key presses from the user's keyboard. Both event listeners call the `handleInput` function which handles all letters (upper and lower case), backspace, and enter. These are the only key inputs relevant to the game. The function handles these inputs by adding/removing letters (typing/pressing backspace respectively), and creating the guess (pressing enter). Letters won't be added once all 5 positions contain a letter and letters won't be removed if there aren't any remaining. The functions `addLetter(letter)` and `removeLetter()` accomplish this with safeguards ensuring that the current index being added to or removed from is within bounds. Adding the last letter technically makes the bound 5 (when the highest should be 4), but this is fine because of the way that removing a letter is handled. Adding a letter increments index afterwards, while removing a letter decrements the index before hand, which balances out the position. The process of guess validation starts with retrieving the letters in the current row. If there are 5 letters, then it must pass the check for unique guesses (avoid repeated guesses). The third check is a simple comparison to see if the user's guess is the answer. If the user properly guessed the word, it pushes the guess into the pastGuesses array. After that, it calls `checkValidPositions(userGuess)` to update the indexes that need to be marked valid for displaying the guess and the letters that must be marked valid on the web keyboard. Indexes are used to reference the particular paragraph child element of the div containing the guess.

The function has many helper functions for the game logic. The `getGuess()` function iterates through the current row, adds each letter to a string, and returns this string in lower case. The first condition for validating a guess is the length of the guess. If it is less than five letters long, it is an invalid guess, so an error is shown using the `showError(errorMsg)` helper function. This function displays a custom made alert shown to the user containing the error message. The alert disappears 2 seconds later and the text content is also reset to an empty string. It is a lot better to create and remove this element, but due to time constraints, this is the method chosen. Some issues include spamming an erroneous action, leading to the alert disappearing and reappearing at seemingly random intervals because the setInterval method is used here. The function `letterCounter(word)` returns an object with letters as keys and the letter's occurrences as the value. This counter is used to handle the edge case of words such as "trust" in which a letter is repeated. The count is needed in order to properly update the existence of letters in the answer. For example, the `filterAnswer()` function is used to remove any letters that the user correctly positioned.

## Event Listeners

| Event Listener | Purpose & Usage |
| --- | ----- |
| `handleSpanHover(e)` | This event listener is used to handle the cursor hovering over a span. The related events are `mouseover` and `mouseout`. If the cursor is over the span, it is a `mouseover` (showing hover styling) and if it is outside, then this counts as a `mouseout` (removing hover styling). Spans are expected to be login/sign up text in this project. The spans in the navbar change color (text becomes a particular color depending on the span) and are underlined while other spans are underlined. Although this could have been done strictly with CSS, it was an interesting function to implement. This event handler is also used in the first element child of the overlay (whenever the overlay is created) to handle styling the span for login or sign up. |
| `handleSpanClick(e)` | This event listener is used to handle clicking on spans. The related event is `click`. As mentioned before, spans are expected to be only login/sign up text and dynamically update an overlay. It removes the first element child of the overlay first (if it exists), disables the event listener for key presses in the body, shows the overlay if needed, and creates the actual overlay content by calling the function `createOverlay`. This function uses a document fragment to create static data or dynamic data unique to the user's experience (the latter describes the result overlay). Initially, the event listener was placed in the body, but later on this led to many errors. That approach was too greedy and it caused the form submit button to stop working. After some debugging, the event listener was improved so that it is only added to spans in the overlay and the navbar. |
| `handleKeyHover(e)` | This event listener is used to handle the cursor hovering over a key on the interactive web keyboard. The related events are `mouseover` and `mouseout`. If the cursor is over the key, it is a `mouseover` (showing hover styling) and if it is outside, then this counts as a `mouseout` (removing hover styling). Similar to the `handleSpanHover(e)`, this could have been accomplished using CSS, but it was worth implementing for the experience. The key with a cursor on it becomes slightly darker because of a filter acting on brightness. A brief transition 0.3 second transition is used. |
| `handleWebKeyboard(e)` | This event listener is used to handle button presses on the web keyboard. The related event is `click`. It calls the `handleInput` function since the input logic for web keyboard users and regular keyboard users is mostly the same. More details about this function are mentioned in game logic section. |
| `handleUserKeyboard(e)` | This event listener is used to handle user input from a user's keyboard. The related event is `keydown`, which handles key presses. A safeguard is implemented to prevent input when they hold the key down (only the first input is counted). It calls the `handleInput` function which handles all letters (upper and lower case), backspace, and enter. These are the only key inputs relevant to the game. This event listener is removed anytime the overlay is shown and added back anytime the overlay is closed. |
| `handleOpenResults(e)` | This event listener is used to allow the user to revisit their results after the game is over. The related event is `click`. If the game is ongoing, the results button is not visible and doesn't have the event listener. |
| `closeOverlay(e)` |  |
| `handleImgHover(e)` |  |
| `handleSignUp(e)` |  |
| `handleLogin(e)` |  |
