# SBA-316
For this SBA, a clone of the popular game wordle was created. The UI mostly resembles the original WORDLE game, but there are a few differences. The web keyboard is more responsive (hovering over each key darkens the key), different login/signup overlay, results overlay displaying a gif, and time elapsed.

## Game Constraints and Issues
This implementation of wordle is almost "perfect" in the sense that it functions almost as expected. The game properly updates colors on the keyboard and guesses based on whether the letter exists, doesn't exist, or is in the correct position. The main flaw is a word list with a small subset of words and the lack of word validation (no logic implemented to validate that a word exists in the English dictionary). The game handles repeated guesses and guesses that are too short with a custom made alert that disappears after 2 seconds with `setTimeOut`. This alert also isn't implemented in the best way since spamming errors will lead to unexpected behavior (the alert randomly disappearing and appearing because the same error is being displayed over and over because textContent of the element child is modified). The web keyboard exists for mobile users and/or desktop users that prefer using these keys to type and primarily as a way for users to keep track of letters in a different way (other than viewing their past guesses). Another issue is if the overlay does not have a child element, then the div cannot be closed.

## Game Logic
This implementation is carried by two event listeners, `handleWebKeyboard(e)` and `handleUserKeyboard(e)`, that handle user input. The first event listener is used to gather user input from the web keyboard, while the latter is used to gather key presses from the user's keyboard. Both event listeners call the `handleInput(letter)` function which handles all letters (upper and lower case), backspace, and enter. These are the only key inputs relevant to the game. The function handles these inputs by adding/removing letters (typing/pressing backspace respectively), and creating the guess (pressing enter). Letters won't be added once all 5 positions contain a letter and letters won't be removed if there aren't any remaining. The functions `addLetter(letter)` and `removeLetter()` accomplish this with safeguards ensuring that the current index being added to or removed from is within bounds. Adding the last letter technically makes the bound 5 (when the highest should be 4), but this is fine because of the way that removing a letter is handled. Adding a letter increments index afterwards, while removing a letter decrements the index before hand, which balances out the position. The process of guess validation starts with retrieving the letters in the current row. If there are 5 letters, then it must pass the check for unique guesses (avoid repeated guesses). The third check is a simple comparison to see if the user's guess is the answer.

### Winning
If the user properly guessed the word, it pushes the guess into the pastGuesses array. After that, it calls `checkValidPositions(userGuess)` to update the indexes that need to be marked valid for displaying the guess and the letters that must be marked valid on the web keyboard. Indexes are used to reference the particular paragraph child element of the div containing the guess. The guess's background colors are updated through `displayGuessColors()` and the keyboard's key colors are updated through `displayKeyboardColors`. The first function accesses a local object of indexes (key is an index, value is the value "exists", "nonexistent", and "valid" which represent yellow, gray, and green respectively). The second function accesses an object of letters (not local to this scope because all guesses impact the final colors of keys on the web keyboard). The game ends by calling the `endGame()` function, which removes the event listeners for making the web keyboard interactive and key presses on the user's own keyboard. The function also attaches the `handleOpenResults(e)` event listener to the results button (a button that only shows up after a game ends) and makes this button visible so that the user can review their results by pressing that button. The last line in `endGame()` makes the overlay visible (since the overlay is display: none). Lastly, the function `createOverlay(category, type)` is called to display the results pop up/overlay with stats based on the user's performance. When a user wins (guesses the word), it will show the number of guesses and time elapsed. The arguments "result" and "win" are passed here. This method will be explained in more detail later on.

### Valid Guess, But Not the Answer
The else condition in `handleInput(letter)` handles guesses that aren't the answer. It starts by calling `checkValidPositions(userGuess)` to update the indexes that need to be marked valid for displaying the guess and the letters that must be marked valid on the web keyboard. This is also helpful for the next step, which is filtering the answer using `filterAnswer()` which removes any letters that the user correctly positioned. The answer itself isn't modified. A copy of the answer with the removed letters is returned. The answer is only filtered if there are any letters in the correct position. The function `checkExistsNotExists(guess, answer)` takes the userGuess and filteredAnswer as arguments to update the object storing indexes and the global scope object for keys, which are used to display colors for guesses and the web keyboard, respectively. This function iterates through the user's guess and uses the a local copy of the object returned from `letterCounter(word)`. The function `letterCounter(word)` returns an object with letters as keys and the letter's occurrences as the value. This counter is used to handle the edge case of words such as "trust" in which a letter is repeated. The count is needed in order to properly update the existence of letters in the answer. If the filtered answer has the current letter and the count is greater than 0, that means the letter is in the answer, but in the wrong position. The letter count is decremented, the local object of indexes now contains the index with the letter that exists in the answer, and adds this entry to the global object of letters (representing the key that should be a specific color) only if it isn't already marked as valid. This is the expected behavior because once a letter is marked valid on the web keyboard, this informs the user that they already correctly positioned that letter at least once. Otherwise, if the current letter isn't in the answer, the local object of indexes marks the index as nonexistent (for coloring purposes) and will only update the global object of letters if the entry related to that letter isn't already valid or exists. This handles edge cases for an answer with multiple occurrences of the same letter. Once the user already guesses the letter and verifies that exists somewhere in the answer, keep it as "exists", and the same logic applies for "valid". The order of importance is basically "valid" > "exists" > "nonexistent". This means "valid" overwrites the latter two and "exists" overwrites "nonexistent". After this function runs, the guess's background colors are updated through `displayGuessColors()` and the keyboard's key colors are updated through `displayKeyboardColors`. The global scope variable `letterPos` which represents the position the user's input is at (the column of this 5 x 6 grid) and the guessPos (the row of the guess, also referred to as the guess number) are updated accordingly (letterPos = 0 and guessPos++). Setting letterPos to 0 is the same as starting a new guess such that the first letter will be at the beginning and incrementing the guessPos represents starting a new guess at the next row. The userGuess is pushed into the pastGuesses array and a check if performed for ending the game. If the current guess count is greater than or equal to the maximum number of guesses, the game is over. This condition is when the user runs out of guesses. It will call the `createOverlay(category, type)` function to create and display the results overlay. This overlay will show time elapsed and the user's stats (how many letters were guessed in the correct position and how many letters were guessed and exist in the word). The arguments "result" and "lose" are passed here. The function will be explained in the next section.

### Creating the Overlay
The contents of the overlay is created in a document fragment, and this fragment is appended as a child to the overlay container (a div). The overlay itself is a partially transparent div that takes up the entire body (width and height) and applies a dark tint. 

### Other Helper Functions
The function has many helper functions for the game logic. The `getGuess()` function iterates through the current row, adds each letter to a string, and returns this string in lower case. The first condition for validating a guess is the length of the guess. If it is less than five letters long, it is an invalid guess, so an error is shown using the `showError(errorMsg)` helper function. This function displays a custom made alert shown to the user containing the error message. The alert disappears 2 seconds later and the text content is also reset to an empty string. It is a lot better to create and remove this element, but due to time constraints, this is the method chosen. Some issues include spamming an erroneous action, leading to the alert disappearing and reappearing at seemingly random intervals because the setInterval method is used here.  For example, the `filterAnswer()` function is used to remove any letters that the user correctly positioned.

## Event Listeners

| Event Listener | Purpose & Usage |
| --- | ----- |
| `handleSpanHover(e)` | This event listener is used to handle the cursor hovering over a span. The related events are `mouseover` and `mouseout`. If the cursor is over the span, it is a `mouseover` (showing hover styling) and if it is outside, then this counts as a `mouseout` (removing hover styling). Spans are expected to be login/sign up text in this project. The spans in the navbar change color (text becomes a particular color depending on the span) and are underlined while other spans are underlined. Although this could have been done strictly with CSS, it was an interesting function to implement. This event handler is also used in the first element child of the overlay (whenever the overlay is created) to handle styling the span for login or sign up. |
| `handleSpanClick(e)` | This event listener is used to handle clicking on spans. The related event is `click`. As mentioned before, spans are expected to be only login/sign up text and dynamically update an overlay. It removes the first element child of the overlay first (if it exists), disables the event listener for key presses in the body, shows the overlay if needed, and creates the actual overlay content by calling the function `createOverlay`. This function uses a document fragment to create static data or dynamic data unique to the user's experience (the latter describes the result overlay). Initially, the event listener was placed in the body, but later on this led to many errors. That approach was too greedy and it caused the form submit button to stop working. After some debugging, the event listener was improved so that it is only added to spans in the overlay and the navbar. |
| `handleKeyHover(e)` | This event listener is used to handle the cursor hovering over a key on the interactive web keyboard. The related events are `mouseover` and `mouseout`. If the cursor is over the key, it is a `mouseover` (showing hover styling) and if it is outside, then this counts as a `mouseout` (removing hover styling). Similar to the `handleSpanHover(e)`, this could have been accomplished using CSS, but it was worth implementing for the experience. The key with a cursor on it becomes slightly darker because of a filter acting on brightness. A brief transition 0.3 second transition is used. |
| `handleWebKeyboard(e)` | This event listener is used to handle button presses on the web keyboard. The related event is `click`. It calls the `handleInput(letter)` function since the input logic for web keyboard users and regular keyboard users is mostly the same. More details about this function are mentioned in game logic section. This is attached to the div that contains the web keyboard. |
| `handleUserKeyboard(e)` | This event listener is used to handle user input from a user's keyboard. The related event is `keydown`, which handles key presses. A safeguard is implemented to prevent input when they hold the key down (only the first input is counted). It calls the `handleInput(letter)` function which handles all letters (upper and lower case), backspace, and enter. These are the only key inputs relevant to the game. This event listener is removed anytime the overlay is shown and added back anytime the overlay is closed. This is attached to the body of the document. |
| `handleOpenResults(e)` | This event listener is used to allow the user to revisit their results after the game is over. The related event is `click`. If the game is ongoing, the results button is not visible and doesn't have the event listener. |
| `closeOverlay(e)` |  |
| `handleImgHover(e)` |  |
| `handleSignUp(e)` |  |
| `handleLogin(e)` |  |
