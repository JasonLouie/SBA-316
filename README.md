# SBA-316
For this SBA, a clone of the popular game wordle was created. The UI mostly resembles the original WORDLE game, but there are a few differences. The web keyboard is more responsive (hovering over each key darkens the key), different login/signup overlay, results overlay displaying a gif, and time elapsed.

## Game Constraints and Issues
This implementation of wordle is almost "perfect" in the sense that it functions almost as expected. The game properly updates colors on the keyboard and guesses based on whether the letter exists, doesn't exist, or is in the correct position. The main flaw is a word list with a small subset of words and the lack of word validation (no logic implemented to validate that a word exists in the English dictionary). The game handles repeated guesses and guesses that are too short with a custom made alert that disappears after 2 seconds with `setTimeOut`. The web keyboard exists for mobile users and/or desktop users that prefer using these keys to type and primarily as a way for users to keep track of letters in a different way (other than viewing their past guesses). Another issue is if the overlay does not have a child element, then the div cannot be closed.

## Game Logic
This implementation is carried by two event listeners, `handleWebKeyboard(e)` and `handleUserKeyboard(e)`, that handle user input. The first event listener is used to gather user input from the web keyboard, while the latter is used to gather key presses from the user's keyboard. Both event listeners call the `handleInput(letter)` function which handles all letters (upper and lower case), backspace, and enter. These are the only key inputs relevant to the game. The function handles these inputs by adding/removing letters (typing/pressing backspace respectively), and creating the guess (pressing enter). Letters won't be added once all 5 positions contain a letter and letters won't be removed if there aren't any remaining. The functions `addLetter(letter)` and `removeLetter()` accomplish this with safeguards ensuring that the current index being added to or removed from is within bounds. Adding the last letter technically makes the bound 5 (when the highest should be 4), but this is fine because of the way that removing a letter is handled. Adding a letter increments index afterwards, while removing a letter decrements the index before hand, which balances out the position. The process of guess validation starts with retrieving the letters in the current row. If there are 5 letters, then it must pass the check for unique guesses (avoid repeated guesses). The third check is a simple comparison to see if the user's guess is the answer.

### Getting the User's Guess and Errors
The function has many helper functions for the game logic. The `getGuess()` function iterates through the current row, adds each letter to a string, and returns this string in lower case. The first condition for validating a guess is the length of the guess. If it is less than five letters long, it is an invalid guess, so an error is shown using the `createError(errorMsg)` helper function. This function displays a custom made alert shown to the user containing the error message. The alert is a div with a paragraph container the error message as its child element. It disappears 3 seconds later (removed from the game container).

### Winning Condition
If the user properly guessed the word, it pushes the guess into the pastGuesses array. After that, it calls `checkValidPositions(userGuess)` to update the indexes that need to be marked valid for displaying the guess and the letters that must be marked valid on the web keyboard. Indexes are used to reference the particular paragraph child element of the div containing the guess. The guess's background colors are updated through `displayGuessColors()` and the keyboard's key colors are updated through `displayKeyboardColors`. The first function accesses a local object of indexes (key is an index, value is the value "exists", "nonexistent", and "valid" which represent yellow, gray, and green respectively). The second function accesses an object of letters (not local to this scope because all guesses impact the final colors of keys on the web keyboard). The game ends by calling the `endGame()` function, which removes the event listeners for making the web keyboard interactive and key presses on the user's own keyboard. The function also attaches the `handleOpenResults(e)` event listener to the results button (a button that only shows up after a game ends) and makes this button visible so that the user can review their results by pressing that button. The last line in `endGame()` makes the overlay visible (since the overlay is display: none). Lastly, the function `createOverlay(category, type)` is called to display the results pop up/overlay with stats based on the user's performance. When a user wins (guesses the word), it will show the number of guesses and time elapsed. The arguments "result" and "win" are passed here. This method will be explained in more detail later on.

### Valid Guess, But Not the Answer
The else condition in `handleInput(letter)` handles guesses that aren't the answer. It starts by calling `checkValidPositions(userGuess)` to update the indexes that need to be marked valid for displaying the guess and the letters that must be marked valid on the web keyboard. This is also helpful for the next step, which is filtering the answer using `filterAnswer()` which removes any letters that the user correctly positioned. The answer itself isn't modified. A copy of the answer with the removed letters is returned. The answer is only filtered if there are any letters in the correct position. The function `checkExistsNotExists(guess, answer)` takes the userGuess and filteredAnswer as arguments to update the object storing indexes and the global scope object for keys, which are used to display colors for guesses and the web keyboard, respectively. This function iterates through the user's guess and uses the a local copy of the object returned from `letterCounter(word)`. The function `letterCounter(word)` returns an object with letters as keys and the letter's occurrences as the value. This counter is used to handle the edge case of words such as "trust" in which a letter is repeated. The count is needed in order to properly update the existence of letters in the answer. If the filtered answer has the current letter and the count is greater than 0, that means the letter is in the answer, but in the wrong position. The letter count is decremented, the local object of indexes now contains the index with the letter that exists in the answer, and adds this entry to the global object of letters (representing the key that should be a specific color) only if it isn't already marked as valid. This is the expected behavior because once a letter is marked valid on the web keyboard, this informs the user that they already correctly positioned that letter at least once. Otherwise, if the current letter isn't in the answer, the local object of indexes marks the index as nonexistent (for coloring purposes) and will only update the global object of letters if the entry related to that letter isn't already valid or exists. This handles edge cases for an answer with multiple occurrences of the same letter. Once the user already guesses the letter and verifies that exists somewhere in the answer, keep it as "exists", and the same logic applies for "valid". The order of importance is basically "valid" > "exists" > "nonexistent". This means "valid" overwrites the latter two and "exists" overwrites "nonexistent". After this function runs, the guess's background colors are updated through `displayGuessColors()` and the keyboard's key colors are updated through `displayKeyboardColors()`. This function accesses an object in the global scope, `keyDict`, to quickly access a key at a particular row and column. The global scope variable `letterPos` which represents the position the user's input is at (the column of this 5 x 6 grid) and the guessPos (the row of the guess, also referred to as the guess number) are updated accordingly (letterPos = 0 and guessPos++). Setting letterPos to 0 is the same as starting a new guess such that the first letter will be at the beginning and incrementing the guessPos represents starting a new guess at the next row. The userGuess is pushed into the pastGuesses array and a check if performed for ending the game.

### Losing Condition
If the current guess count is greater than or equal to the maximum number of guesses, the game is over. This condition is when the user runs out of guesses. It will call the `createOverlay(category, type)` function to create and display the results overlay. This overlay will show time elapsed and the user's stats (how many letters were guessed in the correct position and how many letters were guessed and exist in the word). The arguments "result" and "lose" are passed here. The function will be explained in the next section.

### Creating the Overlay
The contents of the overlay is created in a document fragment, and this fragment is appended as a child to the overlay container (a div). The overlay itself is a partially transparent div that takes up the entire body (width and height) and applies a dark tint. The `category` parameter expects the string "form" or "results" along with a second parameter, `type`, which expects the string "login", "signup", "win", or "lose". The first two types are related to the type of form and the last two are related to the type of results being shown (a distinction for whether the results are for a user that won or lost). The `category` parameter also expects "settings" and "instructions" as possible arguments, but these two are currently not implemeneted. An event listener `handleImgHover(e)`for the child div (child of the overlay container) is added to handle "animating" the image in the results overlay (it just turns the png to a gif) only when the user's cursor is inside the overlay container's child element (and its descendents). This event listener is removed from the overlay container if the category is "form". The form doesn't have any images so the event listener doesn't need to be there anymore. The `handleSpanHover(e)` listener is added to the div container (child element of the overlay container) to handle styling when hovering over spans. An anonymous event listener for `click` is added to prevent clicks within the div container from being registered in the overlay container. This is necessary because there was an issue with pressing the submit button and the event not registering prior to adding this anonymous event listener. This event listeners are explained in the event listeners section later on.

#### Displaying Results
When the category is "results" and the type is either "win" or "lose", the function creates an overlay of the user's results. The structure of the results overlay is a div (container for the results overlay), followed by children elements h1, img (shows a png depending on the user winning or losing), p (key is mainText; this displays whether the use won or lost), a div for stats (contains 2 paragraph elements that are not mentioned in the `resultsForm` object), and two paragraph elements that encourage the user to sign up or log in to view past results. Data persistence for past results haven't been implemented yet, but will be in the future. The styles are created in `styles.css` and styled based on the element's class, id, or the css selector in the style sheet.

#### Displaying the Login/Signup Form
When the category is "form" and the type is either "login" or "signup", the function creates a form. The structure of the form is a div (container for the form), the form itself, followed by children elements (h1, div, inputs, and p). The form iterates through an array of objects that contain information on the element being created and its attributes. When the type is "login", the array `loginForm` from the global scope is used. Otherwise, the type is expected to be "signup" and the function will iterate through the array `signUpForm`. The form's noValidate attribute is set to true to avoid using the built-in validation for inputs. The styles are created in `styles.css` and styled based on the element's class, id, or the css selector in the style sheet. The event listener for validating the form is added to this form, `handleSignUp(e)` for signing up and `handleLogin(e)` for logging in. More details on these event listeners can be found in the event listener section.

### Closing the Overlay
The overlay itself is closed when the user clicks outside of the child element of the overlay div. The structure of the overlay is an overlay div (which is display: none or display: flex, repsectively hiding or showing this div) followed by a child element which only exists when the overlay div is displayed. When the overlay closes, the event listener for the user's physical keyboard is added back to the body only if the game is still not over. If the game is over, this event listener will not be added to the body because there is no reason to expect keyboard presses if the game is over. Keyboard presses will only be handled in its default state when inputting information in the login or signup form.


## Event Listeners

| Event Listener | Purpose & Usage |
| --- | ----- |
| `handleSpanHover(e)` | This event listener is used to handle the cursor hovering over a span. The related events are `mouseover` and `mouseout`. If the cursor is over the span, it is a `mouseover` (showing hover styling) and if it is outside, then this counts as a `mouseout` (removing hover styling). Spans are expected to be login/sign up text in this project. The spans in the navbar change color (text becomes a particular color depending on the span) and are underlined while other spans are underlined. Although this could have been done strictly with CSS, it was an interesting function to implement. This event handler is also used in the first element child of the overlay (whenever the overlay is created) to handle styling the span for login or sign up. |
| `handleSpanClick(e)` | This event listener is used to handle clicking on spans. The related event is `click`. As mentioned before, spans are expected to be only login/sign up text and dynamically update an overlay. It removes the first element child of the overlay first (if it exists), disables the event listener for key presses in the body, shows the overlay if needed, and creates the actual overlay content by calling the function `createOverlay`. This function uses a document fragment to create static data or dynamic data unique to the user's experience (the latter describes the result overlay). Initially, the event listener was placed in the body, but later on this led to many errors. That approach was too greedy and it caused the form submit button to stop working. After some debugging, the event listener was improved so that it is only added to spans in the overlay and the navbar. |
| `handleKeyHover(e)` | This event listener is used to handle the cursor hovering over a key on the interactive web keyboard. The related events are `mouseover` and `mouseout`. If the cursor is over the key, it is a `mouseover` (showing hover styling) and if it is outside, then this counts as a `mouseout` (removing hover styling). Similar to the `handleSpanHover(e)`, this could have been accomplished using CSS, but it was worth implementing for the experience. The key with a cursor on it becomes slightly darker because of a filter acting on brightness. A brief transition 0.3 second transition is used. |
| `handleWebKeyboard(e)` | This event listener is used to handle button presses on the web keyboard. The related event is `click`. It calls the `handleInput(letter)` function since the input logic for web keyboard users and regular keyboard users is mostly the same. More details about this function are mentioned in game logic section. This is attached to the div that contains the web keyboard. |
| `handleUserKeyboard(e)` | This event listener is used to handle user input from a user's keyboard. The related event is `keydown`, which handles key presses. A safeguard is implemented to prevent input when they hold the key down (only the first input is counted). It calls the `handleInput(letter)` function which handles all letters (upper and lower case), backspace, and enter. These are the only key inputs relevant to the game. This event listener is removed anytime the overlay is shown and added back anytime the overlay is closed. This is attached to the body of the document. |
| `handleOpenResults(e)` | This event listener is used to allow the user to revisit their results after the game is over. The related event is `click`. If the game is ongoing, the results button is not visible and doesn't have the event listener. |
| `closeOverlay(e)` | This event listener is used to close the overlay container and return to the main contents of the page. The related event is `click`. |
| `handleImgHover(e)` | This event listener is used to handle "animating" the image in the results overlay (it just turns the png to a gif) only when the user's cursor is inside the overlay container's child element (and its descendents). Otherwise, the img returns to its original png state. The related events are `mouseover` and `mouseout`. It is only added to the overlay container div when displaying results, but removed whenever the form appears. |
| `handleSignUp(e)` | This event listener handles users signing up and creating new accounts. The related event is `submit` and the event listener is added directly to this form. The form consists of three fields: email, password, and confirm password. In the scope of this project, a valid email must not be blank, must match the template of an email (see code for template used), and must be unique (other users should not be able to use this email when signing up). Password must not be blank, must be at least 10 characters long, must contain at least one special character, cannot contain the word password (any case), and the password entered and the confirmed password must be equal. Local storage is used to cache user credentials, which are stored in an array of user objects converted into a string. The user object with these credentials are added only after these tests pass. Otherwise, the errors are shown underneath each field (except for confirm password, which doesn't need its own error message because it is displayed as a password error). Though not explicitly mentioned, the helper functions `validateEmail()` and `validatePassword()` handle this logic. The user can swap between logging in and signing in. |
| `handleLogin(e)` | This event listener handles users logging in with their account credentials. The related event is `submit` and the event listener is added directly to this form. The form consists of two fields: email and password. In the scope of this project, a valid email must not be blank and must exist in the local storage. The password must not be blank and when verifying the login, that password must match that specific user object's email.Otherwise, the errors are shown underneath each field. Though not explicitly mentioned, the helper functions `validateEmail()` and `validatePassword()` handle this logic. The user can swap between logging in and signing in. |